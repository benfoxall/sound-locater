<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <canvas width="500" height="500"></canvas>
    <script type="text/javascript">
    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var analyser = audioCtx.createAnalyser();

    var canvas = document.querySelector('canvas')
    var canvasCtx = canvas.getContext('2d')
    canvasCtx.fillStyle = 'rgb(200, 200, 200)'
    canvasCtx.strokeStyle = '#fff'
    var WIDTH = HEIGHT = 500

    // analyser.fftSize = 2048;
    // analyser.minDecibels = -300

    analyser.fftSize = 4096;


    var bufferLength = analyser.frequencyBinCount;
    var dataArray = new Uint8Array(bufferLength);

    // analyser.getByteTimeDomainData(dataArray);

    // draw an oscilloscope of the current audio source
    function draw(t) {

        drawVisual = requestAnimationFrame(draw)


        // analyser.getByteFrequencyData(dataArray);

        analyser.getByteTimeDomainData(dataArray);
        var ac = autoCorrelate( dataArray, audioCtx.sampleRate )



        // console.log(ac)


        if(ac != -1) {
          console.log(ac)
          if(ac > 300 && ac < 500) {
            if(
              Math.abs(ac-350) < Math.abs(ac-450)
            ) {
              canvasCtx.fillStyle = '#08f'
            } else {
              canvasCtx.fillStyle = '#f08'
            }
          }
        }

        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

        canvasCtx.lineWidth = 2;
        // canvasCtx.strokeStyle = 'rgb(0, 0, 0)';

        canvasCtx.beginPath();

        var sliceWidth = WIDTH * 1.0 / bufferLength;
        var x = 0;

        for(var i = 0; i < bufferLength; i++) {

          var v = dataArray[i] / 128.0;
          var y = v * HEIGHT/2;

          if(i === 0) {
            canvasCtx.moveTo(x, y);
          } else {
            canvasCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        canvasCtx.lineTo(canvas.width, canvas.height/2);
        canvasCtx.stroke();
      };

      draw();





      navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false
      })
        .then(function(mediaStream) {
          window.x = mediaStream
          var source = audioCtx.createMediaStreamSource(mediaStream)
          source.connect(analyser)
         })
        .catch(function(error) {
          console.log(error)
         })





         // Taken from WAD https://github.com/rserota/wad/blob/master/src/wad.js#L939-L985
         function autoCorrelate( buf, sampleRate ) {
          //  console.log(buf.length, sampleRate)
             var MIN_SAMPLES = 4;    // corresponds to an 11kHz signal
             var MAX_SAMPLES = 1000; // corresponds to a 44Hz signal
             var SIZE = 1000;
             var best_offset = -1;
             var best_correlation = 0;
             var rms = 0;
             var foundGoodCorrelation = false;

             if (buf.length < (SIZE + MAX_SAMPLES - MIN_SAMPLES))
                 return -1;  // Not enough data

             for ( var i = 0; i < SIZE; i++ ) {
                 var val = ( buf[i] - 128 ) / 128;
                 rms += val * val;
             }
             rms = Math.sqrt(rms/SIZE);
             if (rms<0.01)
                 return -1;

             var lastCorrelation=1;
             for (var offset = MIN_SAMPLES; offset <= MAX_SAMPLES; offset++) {
                 var correlation = 0;

                 for (var i=0; i<SIZE; i++) {
                     correlation += Math.abs(((buf[i] - 128)/128)-((buf[i+offset] - 128)/128));
                 }
                 correlation = 1 - (correlation/SIZE);
                 if ((correlation>0.9) && (correlation > lastCorrelation))
                     foundGoodCorrelation = true;
                 else if (foundGoodCorrelation) {
                     // short-circuit - we found a good correlation, then a bad one, so we'd just be seeing copies from here.
                     return sampleRate/best_offset;
                 }
                 lastCorrelation = correlation;
                 if (correlation > best_correlation) {
                     best_correlation = correlation;
                     best_offset = offset;
                 }
             }
             if (best_correlation > 0.01) {
                 // console.log("f = " + sampleRate/best_offset + "Hz (rms: " + rms + " confidence: " + best_correlation + ")")
                 return sampleRate/best_offset;
             }
             return -1;
         //  var best_frequency = sampleRate/best_offset;
         }


    </script>
  </body>
</html>
